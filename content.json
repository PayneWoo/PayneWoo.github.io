[{"title":"ARTS for 1st week！","date":"2019-01-19T16:00:00.000Z","path":"2019/01/20/ARTS_for_1st_week/","text":"What’s ARTS? Algorithm：每周至少做一个 LeetCode 的算法题；Review：阅读并点评至少一篇英文技术文章；Tip/Techni：学习至少一个技术技巧；Share：分享一篇有观点和思考的技术文章。 Algorithm —- 链表相关本周回顾了几个经典的 链表 相关算法题： LeetCode-19. Remove Nth Node From End of List（删除链表的倒数第 N 个结点）Remove Nth Node From End of List 题目分析：由于是单链表，要删除某个结点，就必须得知道这个结点的前一个结点，所以问题就转变为找倒数第 N+1 个结点。在不知道链表长度的情况下，如何通过一次遍历来定位倒数第 N+1 个结点呢？通过设置两个指针（或者说引用）first , second ，让两个指针距离合适的长度，然后同步移动，就能定位倒数第 N+1 个结点了。代码如下：1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; if (head == null) &#123; return null; &#125; // 哨兵结点的存在，使得删除第一个结点和删除其他结点都可以统一为相同的代码实现逻辑 ListNode start = new ListNode(0); // 哨兵结点 ListNode first = start; ListNode second = start; start.next = head; // 移动 first , 使得 first 和 second 相距 n+1 个结点 for (int i = 1; i &lt;= n + 1; i++) &#123; first = first.next; &#125; // first 和 second 同步向后移动 while (first != null) &#123; // while 循环结束后，second指针就指向了第倒数 n + 1 个结点，即待删除结点的前一个结点 second = second.next; first = first.next; &#125; // 删除倒数第 n 个节点 second.next = second.next.next; return start.next; &#125;&#125; 这里采用哨兵结点，来使得删除第一个结点跟删除其他结点都能统一为相同的代码实现逻辑。 LeetCode-141.Linked List Cycle（判断链表是否有环）Linked List Cycle 题目分析：经典的实现就是采用 快慢指针 ， 如果链表存在环的话，那么快指针 fast 跟慢指针 slow 是一定会相遇的！代码如下： 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) &#123; // 快慢指针相遇，说明有环 return true; &#125; &#125; return false; &#125;&#125; 这里要警惕指针丢失，while 判断里头不要丢了 fast.next != null LeetCode-142.Linked List Cycle II（找到带环链表的环入口）Linked List Cycle II 题目分析：判断链表有环很容易，那么环的入口如何知道呢？敲黑板，划重点：快慢指针相遇的结点 meet 到环入口结点的距离 等于 头结点 head 到环入口结点的距离。代码如下： 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode fast = head; ListNode slow = head; ListNode meet = null; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) &#123; meet = slow; // 相遇点 break; &#125; &#125; // 快慢指针相遇的结点 meet 到环起点的距离 = head到环起点的距离 if (meet != null) &#123; while (meet != head) &#123; meet = meet.next; head = head.next; &#125; &#125; return meet; &#125;&#125; LeetCode-206.Reverse Linked List（链表反转）Reverse Linked List 题目分析：相当经典的一道题，面试官也是喜欢考。这个题也是通过 3 个指针的移动、变换，从而能通过一次遍历，就能反转链表。 head：当前结点pre：当前结点的前一个结点next：当前结点的下一个结点 再反转指针指向之前，一定要把 下一个结点 先保存起来，不然弄丢了，你去哪儿找，对应代码的第 17 行。这个题，比较抽象，用手画图理解是个好办法。 代码如下： 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode pre = null; ListNode next = null; while (head != null) &#123; next = head.next; // next 保存 head 的下一个结点 head.next = pre; // 反转 pre = head; // pre 指针右移 head = next; // head 指针右移 &#125; return pre; // while 循环走完后，pre 会走到旧链表的链尾，即新链表的链头 &#125;&#125; LeetCode-876. Middle of the Linked List（找链表的中间结点） Middle of the Linked List 题目分析：根据题目描述，如果能知道链表的长度 N，那么中间结点就是第 N/2 + 1 个结点。所以，一种实现办法就是，先遍历链表得到链表长度 N , 然后再从头结点找 第 N/2 + 1 个结点。但是，这种实现需要遍历链表两次，有点难受，实际上，这里也可以采用快慢指针来解决。代码如下： 解法一：1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode middleNode(ListNode head) &#123; if (head == null) &#123; return null; &#125; if (head.next == null) &#123; return head; &#125; int len = 0; // 链表长度 ListNode newHead = head; while (head != null) &#123; head = head.next; len++; &#125; int mid = len / 2 + 1; // 链表的中间位置 for (int i = 0; i &lt; mid - 1; ++i) &#123; newHead = newHead.next; &#125; return newHead; &#125;&#125; 解法二：快慢指针1234567891011/*** 解法二：快慢指针，优秀哇，一次遍历就搞定了！*/public ListNode middleNode(ListNode head) &#123; ListNode slow = head, fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; return slow;&#125; Review —- Software Engineering at Google前几天，在 湾区日报 上看到推送了这篇《Software Engineering at Google 》，比较感兴趣，想了解了解世界一流的互联网公司的开发流程及规范。文章链接 在这儿 ，推荐大家有空时也读一读。 这篇文章是 Google的 骨灰级码农 Fergus Henderson 写的。比较详细的介绍了 Google 公司的 软件管理、项目管理、人员管理 。 Software development主要了解下软件管理，从以下几个维度对 Google 公司的开发流程及规范做了介绍： 1、Google 的代码管理2、Blaze：分布式构建系统3、Code Review：代码审查4、Testing：单元、集成、回归测试5、Bug tracking：Buganizer —- Bug tracking system.6、Programming languages：5种编程语言，代码风格一致7、Debugging and Profiling tools：调试和分析工具8、Release engineering：发布工程9：Launch approval 启动批准10、Post-mortems：事故复盘，总结经验教训11：Frequent rewrites：经常重写项目 总结：Google 作为世界一流的互联网企业，其软件开发流程是非常规范的，毕竟人家是这个行业的先行者，是这个行业的标杆。Code Management 和 Code Review 让人印象深刻！事实上，也能从国内的互联网公司的开发流程中看到 Google 软件管理的影子。 Tip/Tech解决链表相关算法题的一些技巧： 1、理解指针或引用的含义 2、警惕指针丢失和内存泄漏 3、利用哨兵简化实现难度 4、重点留意边界条件处理如果链表为空时，代码能否正常工作？如果链表只包含 1 个结点时，代码能否正常工作？如果链表只包含 2 个结点时，代码能否正常工作？代码逻辑在处理头结点和尾结点时，能否正常工作？ 5、举例画图，辅助思考 Share分享一个系列文章：Google Chrome 的调试工具技巧：Chrome 的调试工具技巧","tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://yoursite.com/tags/ARTS/"}]},{"title":"MySQL索引","date":"2018-07-02T16:00:00.000Z","path":"2018/07/03/MySQL_Index/","text":"MySQL 索引1.1 索引的优点优点：极大的提高了查询效率 没有索引的数据表就是一个无序的数据行的集合，如果想在无索引的数据表中查找数据，就需要一条一条的检查每一个数据行，直到找到匹配的结果。如果此时数据表中有 10000 条数据，那么平均也得查找 5000 次，才能找到要找的数据，这样一来，效率就太低了。 而使用索引的目的，就是为了提高查询效率。 索引值是经过分类的，索引中包含了数据表里的每一个数据行的项。那么索引为什么能提高查询效率呢？ （1）可以得知匹配数据行在什么位置结束，从而跳过其余部分； （2）因为使用了定位算法，它们可以不用从索引开始位置经过线性扫描就能直接找到第一个匹配项（例如，二进制搜索就比扫描快许多） 不同数据库引擎的索引实现细节：InnoDB —– 数据表的数据和索引存在同一个表空间文件InnoDB 存储引擎使用的是一个表空间，在这个表空间里，它管理着所有的 InnoDB 类型数据表的数据和索引的存储。即使通过配置让 InnoDB 为每个数据表分别创建一个它自己的表空间，一个给定的数据表的数据和索引也是保存在同一个表空间文件里。MyISAM —– 数据表的数据行是在数据文件里，而索引值是在索引文件里一个数据表可以有多个索引，所有的索引都存储在同一个索引文件里，索引文件里的每一个索引都是由分类的关键记录数组组成的，这些数组用于快速访问数据文件。 1.2 索引的缺点1）索引加快了检索速度，但是降低了在带索引的数据列里插入、删除以及修改数值的速度。（即索引降低了涉及写入的操作的速度） 原因：写入一条数据行，不仅要求写入到数据行，还要求所有的索引都要随之做出改变，一个表有越多的索引，需要做出的改变就越多，平均性能就会下降越多。 2）索引要占据磁盘空间。 1.3 如何确定要索引的数据列1、为用来搜索（WHERE）、分类或者分组（GROUP BY）的数据列编制索引，不要为输出显示（SELECT）的数据列编制索引最适合索引的数据列是那些在 WHERE 子句中出现的数据列、在联结子句中给出的数据列，或者是在 ORDER BY 或 GROUP BY 子句中出现的数据列。根据 SELECT 关键字仅出现在输出数据列清单里的数据列最好不要有索引。 2、考虑各数据列的维度什么是维度？ —– 数据列的维度等于它所容纳的非重复值得个数。比如，某个数据列里的值是（1，2 ， 2， 3 ，3 ，4），它的维度就是 4 。维度越高，重复值越少，索引的效果也越好。 3、尽量选用比较不占内存的数据类型短小的值可以加快索引查找速度、减少磁盘 I/O 、让MySQL 在内存里同时容纳更多的键，从而加大在不需要从磁盘读取更多索引块的前提下在内存里找到键值的概率。 4、为字符串值得前缀编索引假设有一个 CHAR（300）的数据列，而且大多数值的前 10 或 20 个字符都是唯一的，那么就不用为整个数据列编制索引，而只需要为前面的 20 或者 30 个字符编制索引就行了，这样可以降低索引占据的内存空间，而且会使得查询更快。 5、充分利用最左边的前缀创建一个 n 个数据列的复合索引，实际上就创建了 n 个索引。一个复合索引在工作时，就相当于 n 个索引，因为索引中最左边的数据列集合能够用于匹配数据行，这样的一个集合就被称为“最左边的前缀”。 MySQL 不能使用没有包含最左边前缀的搜索的索引。假设有个数据表，数据表有复合索引，数据列名称是 state（州）、city（城市）、code（邮编）。索引中的数据行是以 州/城市/邮编 的顺序存储的，因此它们自动以 州/城市 的顺序，也以 州 的顺序分类。所以，索引可以用来搜索一下的数据列的组合： 123state, city, codestate, citystate 如果使用 state, code ，这时，尽管 MySQL 可以使用索引来找到那些与这个州匹配的数据行从而缩小搜索范围，但是这个索引不能用于值的组合。 6、利用“慢查询”日志找出性能低劣的查询“慢查询”日志是一个文本文件，如果在这个日志里经常出现某个查询命令，就意味着它的代码可能不够优化。所以这个日志可以帮助我们找出可能受益于使用索引的查询命令。 7、索引的类型要与打算进行比较操作的类型保持匹配 索引有哪些类型（从数据结构角度分）：1）B+树索引2）hash 索引3）FULLTEXT 索引4）R-Tree 索引 InnoDB 总是使用 B树索引；MyISAM 也是用 B树索引，但在遇到空间数据类型时会改用 R树索引。 1.4 MySQL 使用索引的方式1）在查询操作中把与 WHERE 子句所给出的条件相匹配的数据行尽快找出来；在关联操作中把与其他数据表里的数据行相匹配的数据行尽快找出来2）对于使用 MAX() 和 MIN() 函数的查询，如果数据列带有索引，那么最大值和最小值可以快速找到，而不用逐行检查来查找。3）MySQL 使用索引来迅速完成 ORDER BY 和 GROUP BY 子句的分类和分组操作 1.5 索引原理数据库的数据是存储在磁盘上的，为了提高效率，会把部分数据缓存在内存中。而访问磁盘的代价约是访问内存代价的 10000 倍，所以，降低访问磁盘的次数，是索引所采用的数据结构的目的。那么就需要一个高度可控的多路搜索树，就这样 B+ 树应运而生。 B+ 树B-树索引：B-Tree索引是最常用的一种索引，如果没有指定特定的类型，那么多半就是B-Tree索引，事实上，很多搜索引擎使用的是它的变种 B+树，这是对B-树的一个优化。B+树索引：B+ 树在节点访问时间远远超过节点内部访问时间的时候，通常在多数节点在次级存储比如硬盘中的时候出现。通过最大化在每个内部节点内的子节点的数目来减少树的高度，从而减少磁盘 I/O 次数 B+树性质：1）IO次数取决于B+数的高度 h。假设 N(数据表的数据），m(每个磁盘块的数据项的数量)。 m = 磁盘块的大小(大小是固定的) / 数据项(即索引字段)的大小结论1： m 越大，h 越小，则 I/O 次数越少&gt;结论2：数据项（即索引字段）越小（则 m 越大），I/O次数越少。这就是为什么每个索引字段越小，可以减少 磁盘 I/O 的根本原因。结论3：数据项越少，那么数据项的数目就越多，所以 B+ 树要求把数据项都放到叶子节点。 2）当 B+ 树的数据项是复合的数据结构，比如(name,age,sex)的时候，B+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，B+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，B+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，B+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性 参考资料： MySQL技术内幕（第4版）美团点评技术团队： https://tech.meituan.com/mysql-index.html 欢迎访问我的网站：https://paynewoo.github.io/","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Javac","date":"2018-06-30T16:00:00.000Z","path":"2018/07/01/Javac/","text":"要点： 1、Javac 如何将 Java 的源代码转化为 class 字节码？2、Javac 的语法树结构；3、Javac 的详细工作流程；4、Java 中如何实现内部类？5、Javac 与其他编译器的比较； 1 什么是 Javac ?Javac 是一种编译器，其作用是将 Java 源程序 编译成符合 JVM 规范的 Java 字节码（即 JVM 可以解释执行的二进制码） 2 Javac 的基本结构Javac 主要的四个模块： 词法分析器组件：从源代码中识别出哪些字节是我们定义的语法关键字，如 if、else、for 等等。语法分析器组件：形成一个符合 JVM 规范的抽象语法树。（抽象语法树是一个结构化的语法表达形式，作用是把语言的主要词法用一个结构化的形式组织在一起）语义分析器组件：主要作用是将复杂的语法转化成更简单的语法字节码生成器组件：根据经过注解的抽象语法树生成字节码 3 Javac 工作原理分析词法分析器：这个过程在 JavacParser 的 ParseCompilationUnit 方法中完成的，它的源代码可以通过 OpenJDK 下载来查看。该方法从源文件的第一个字符开始，逐个字符的检查，按照 Java 语法规范依次找出 package、import、类定义、以及属性和方法定义等，将这个类中的所有关键词匹配到Token类的所有项中的任何一项，即将Java源文件的字符流转变为对应的Token流，最后构建一个抽象语法树。 语法分析器：将词法分析器分析的 Token 流组建成更加结构化的语法树，也就是将一个个单词组装成一句话，一个完整句子。具体一点说就是按照一定的规则逐个地解析 Token 流中的每一项，每个语法树上的节点都是 com.sun.tools.javac.tree.JCTree 的一个实例。 语义分析器：在这课语法树上再进行一些处理以产生Java字节码。如给类添加默认的构造函数、检查变量在使用之前是否已经初始化、将一些常量进行合并处理、检查操作变量类型是否匹配、检查所有操作语法是否可达、检查异常是否捕获或掷出等。最后得到完善的最终的语法树。 代码生成器：遍历最终语法树生成 Java 字节码，这步通过 com.sun.tools.javac.jvm.Gen 这个类来完成。生成字节码需要进过两步：首先将 Java 方法中的代码块转成符合 JVM 语法树的命令形式，JVM 的操作都是基于栈的，所有操作都必须经过出栈和进栈来完成。然后，按照 JVM 的文件组织格式将字节码输出到以 class 为扩展名的文件中。 4 访问者模式4.1 设计初衷：将稳定的数据结构和对数据结构的操作解耦。 4.2 访问者模式中包含的角色：抽象访问者（Visitor）具体访问者（ConcreteVisitor）抽象节点元素（Element）具体节点元素（ConcreteElement）结构对象（ObjectStructure）：它持有整个 抽象语法树，它提供一个接口。客户端 调用 访问者 ，通过这个接口就能访问到 节点元素。客户端（Client） 4.3 Javac 中访问者模式的实现（1）Javac 中哪里用到了访问者模式？Javac 的四个主要模块中有很多遍历抽象语法树的过程。访问抽象语法树的节点元素的过程就是一个访问者模式。 （2）Javac 中使用访问者模式有什么好处？访问者模式可以将 抽象语法树 和 对抽象语法树的操作 解耦，从而使得增加对抽象语法树的操作，而不需要去修改 抽象语法树，也不必修改以前 对抽象语法树的操作，只要执行时再定义新的 访问者 就行了。 （3）访问者是如何访问 抽象语法树的节点元素的？客户端 调用 访问者 ，通过结构对象提供的接口就能访问到 节点元素。 （4）为什么不同的访问者访问同一套数据结构（Javac 中是抽象语法树），而访问者的行为却各自不同？遍历抽象语法树使用统一的 accept 接口，每个节点元素都会实现这个接口，但是不同的节点元素的 accept 实现是不同的，所以不同的访问者访问不同的节点元素就会得到不同的结果。 参考书籍：《深入分析 JavaWeb 技术内幕》","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]}]